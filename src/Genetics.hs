-- |
-- Genetics
-- provides a common interface for implementing genetic algorithms
module Genetics
       (Gene(..),
        evolve,
        best
       ) where

import Control.Parallel.Strategies (parMap, rseq)

import Data.List (maximumBy)
import Data.Ord (comparing)

-- | Gene is a typeclass for defining genetic algorithm
--   search strategies
class Gene g where
  -- | How ideal is the gene from 0.0 to 1.0?
  fitness :: g -> Float

  -- | How does a gene mutate?
  mutate :: g -> IO g

  -- | How many species will be explored in each round?
  species :: [g] -> Int

-- | Uses 'fitness' and 'maximumBy' to find the best gene
--   in a list of genes.
best :: Gene g => [g] -> g
best = maximumBy (comparing fitness)

-- | Prevents stack overflow. What does? If the
--   fitness of the 'Gene' is 1.0 we stop evolving it.
mutate' :: Gene g => g -> IO g
mutate' gene
  | fitness gene /= 1.0 = mutate gene
  | otherwise = return gene

-- | Return a randomized version of the list of candidate lists.
drift :: Gene g => [[g]] -> IO [[g]]
drift = mapM (mapM mutate')

-- | Run a round of competition between candidate lists generated by the
--   randomized drift function.
compete :: Gene g => [g] -> IO [g]
compete pool
  | any ((/= 1.0) . fitness) pool = fmap parFindBest candidates
  | otherwise = return pool
  where parFindBest = pmap best
        candidates  = drift (pmap (replicate (species pool)) pool)
        pmap = parMap rseq

-- | Recursively evolves the pool using compete to run the randomized
--   generations
evolve :: Gene g => Int -> [g] -> IO [g]
evolve 0 pool = return pool
evolve n pool = compete pool >>= evolve (n-1)
